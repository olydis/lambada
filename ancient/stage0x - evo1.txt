I = U U.
K = U U I..
S = U K.
B = S K S.. K.
C = S S K S.. S K K.. S... K K..
I = I
K = B K. I.
S = C B B. B S. C B B. I.. I.... C B B. I.. I..
B = C B B. B B. I... C B B. I.. I..
C = C B B. B C. C B B. I.. I.... I.
M = S I. I.
Y = B M. C B B. I.. S I. I...
TRUE = K
FALSE = K I.
IF = I
NOT = C C I. FALSE.. TRUE.
AND = C B C. C B B. I.. I... FALSE.
OR = C B B. C I. TRUE... I.
IMPLIES = C B C. C B B. I.. I... TRUE.
XOR = C B S. C B B. B IF. I... B NOT. I.... I.
EQ = B B NOT.. C B B. B XOR. I... I..
Succ = S B.
zero = K I.
one = Succ zero.
Apply = I
Add = S I. K S B...
Mul = B
Pow = S K S S S K..... K.
isZero = C C I. K FALSE... TRUE.
makePair = C B B. B C. B C I.. I.... I.
fst = C I. B K. I..
snd = C I. K I..
changeFst = S B C. B B makePair.. B C I.. B fst. I..... B snd. I..
changeSnd = S B B. B makePair. B fst. I.... B C I.. B snd. I...
Pred = B B B snd... C B C. B B B.. C B B. I.. B B makePair FALSE... C B S. B C C B IF. B fst. I... I... I... B snd. I....... B makePair TRUE.. I...
Sub = Y B S B S. B C B IF. B isZero. I.... I.... C B C. B B B.. C B B. I.. B Pred. I..... B Pred. I....
isEQ = S B S. B B AND.. B B isZero.. C B B. B Sub. I... I..... B B isZero.. B C B Sub. I... I...
isLTE = B B isZero.. C B B. B Sub. I... I..
isGTE = B C B isLTE. I... I.
isLT = B B NOT.. C B B. B isGTE. I... I..
isGT = B B NOT.. C B B. B isLTE. I... I..
Min = C B S. S B C. B B IF.. C B B. B isLT. I... I.... I... I.
Max = C B S. S B C. B B IF.. C B B. B isGT. I... I.... I... I.
Mod = Y B S B S. S B C. B B IF.. C B B. B isLT. I... I.... I.... C B C. B B S.. C B B. B B. I... C B B. B Sub. I... I..... I...
Div = Y B S B S. C B C. B B IF.. C B B. B isLT. I... I.... zero.... B B B Succ... C B C. B B S.. C B B. B B. I... C B B. B Sub. I... I..... I....
ZfromN = B makePair FALSE.. I.
Zzero = ZfromN zero.
ZisZero = B isZero. B snd. I..
ZisNeg = fst
ZabsN = snd
Znorm = S C B IF. B ZisZero. I... Zzero.. I.
ZNegate = B Znorm. S B makePair. B NOT. B ZisNeg. I.... B snd. I...
ZSucc = B Znorm. S B makePair. B ZisNeg. I... S S B IF. B ZisNeg. I... B Pred. B snd. I.... B Succ. B snd. I.....
ZPred = B ZNegate. B ZSucc. B ZNegate. I...
ZMul = B B Znorm.. S B S. B B makePair.. C B B. B XOR. B ZisNeg. I.... B ZisNeg. I..... C B B. B Mul. B ZabsN. I.... B ZabsN. I....
ZDiv = B B Znorm.. S B S. B B makePair.. C B B. B XOR. B ZisNeg. I.... B ZisNeg. I..... C B B. B Div. B ZabsN. I.... B ZabsN. I....
xzadd = S B S. B S B IF. B NOT. B ZisNeg. I..... B B ZfromN.. C B B. B Add. B ZabsN. I.... B ZabsN. I...... S B S. S B S. B B IF.. C B B. B isLT. B ZabsN. I.... B ZabsN. I..... B B makePair TRUE... B C B Sub. B ZabsN. I.... B ZabsN. I...... B B makePair FALSE... C B B. B Sub. B ZabsN. I.... B ZabsN. I.....
ZAdd = B B Znorm.. S B S. S B B. B IF. B ZisNeg. I.... B B ZNegate.. C B B. B xzadd. B ZNegate. I.... B ZNegate. I...... C B B. B xzadd. I... I...
ZSub = C B B. B ZAdd. I... B ZNegate. I..
ZMod = B B Znorm.. C B B. B changeSnd. I... B C B Mod. I... B ZabsN. I....
ZModX = B B Znorm.. C B S. B B changeSnd.. C B S. B B ZAdd.. C B B. B changeSnd. I... B C B Mod. I... B ZabsN. I...... I.... B C B Mod. I... B ZabsN. I....
listIsNotEmpty = fst
listIsEmpty = B NOT. listIsNotEmpty.
listHead = B fst. snd.
listTail = B snd. snd.
listEmpty = makePair FALSE. I.
listAddFront = B B makePair TRUE... B C B makePair. I... I..
foldl = Y C B C. B B S.. B B B C... B S B B. B B. B IF. B listIsNotEmpty. I...... C B C. B B C.. B B B S... C B S. B B B.. B B B.. C B B. I.. B listTail. I...... B C B C. B C I.. I.... B listHead. I....... I...... I..
foldr = Y C B C. B B S.. B B B C... B S B B. B B. B IF. B listIsNotEmpty. I...... C B S. B B C.. B B B C... B B B S I.... C B C. B B C.. B B B B... C B C. B B B.. C B B. I.. B listTail. I..... I..... I...... B listHead. I....... I..
reverseBag = Y C B C. B B S.. B S B B. B IF. B listIsNotEmpty. I..... C B S. B B B.. C B B. I.. B listTail. I..... B C B listAddFront. I... B listHead. I....... I..
reverse = C B reverseBag. I.. listEmpty.
unfold = Y C B S. B B C.. B B B listAddFront... C B C. B B S.. C B B. B B. I... B C I.. I..... I..... I..
repeat = C B unfold. I.. I.
listCons = C B C. C B B. B foldr. I... I... listAddFront.
listReturn = listAddFront listEmpty.
listAddBack = C B B. B listCons. I... B listReturn. I..
cfold = Y C B C. B B S.. B B B C... B B B B listAddFront.... B S B B. B B. C B IF. B listIsEmpty. I... listEmpty..... C B C. B B C.. B B B S... C B S. B B B.. B B B.. C B B. I.. B listTail. I...... B C B C. B C I.. I.... B listHead. I....... I....... I..
listTake = Y B S B S. C B C. B B IF.. B C B OR. B isZero. I.... B listIsEmpty. I..... listEmpty.... C B S. B B C.. B B B listAddFront... C B C. B B B.. C B B. I.. B listTail. I..... B Pred. I...... B listHead. I....
listTakeWhile = Y B S B S. C B C. B B IF.. S B B. B OR. B listIsEmpty. I.... B B NOT.. B C I.. B listHead. I....... listEmpty.... C B S. B B C.. B B B listAddFront... C B C. B B B.. C B B. I.. B listTail. I..... I..... B listHead. I....
listBind = C B B. C B foldl. I.. listEmpty... B C B B. B listCons. I.... C B B. I.. I...
listMap = C B B. B listBind. I... B B listReturn.. I..
listWhere = C B B. C B foldr. I.. listEmpty... C B S. B B C.. C B B. B S. B B IF.. C B B. I.. I..... C B B. B listAddFront. I... I..... I..
listSkip = Y B S B S. S B C. B B IF.. B C B OR. B isZero. I.... B listIsEmpty. I..... I.... C B C. B B B.. C B B. I.. B listTail. I..... B Pred. I....
listSkipWhile = Y C B S. B B C.. B S B S. B B IF.. S B C. B B AND.. B C I.. B listHead. I..... B NOT. B listIsEmpty. I....... C B C. B B B.. C B B. I.. B listTail. I..... I..... I..
listAny = B B NOT.. B B listIsEmpty.. C B B. B listWhere. I... I...
listAll = B B NOT.. C B B. B listAny. I... B B NOT.. I...
ORs = C B listAny. I.. I.
ANDs = C B listAll. I.. I.
listCount = C C B foldl. I.. zero.. B K. Succ..
listZip = Y B S B S. B B B.. C B C. B B IF.. C B B. B OR. B listIsEmpty. I.... B listIsEmpty. I..... listEmpty..... C B S. B B S.. B B B S... B B B B listAddFront.... C B C. B B C.. B B B B... C B C. B B B.. C B B. I.. B listTail. I..... B listTail. I...... I...... C B B. B C. B C I.. B listHead. I..... B listHead. I.....
listZipLonger = Y B S B S. B B S.. B B B S... S B S. B B B.. B B B.. B B IF.. C B B. B OR. B listIsEmpty. I.... B listIsEmpty. I....... S B C. B B S.. B B B S... C B B. B B. B B. B IF. B listIsEmpty. I...... C B C. B B B.. B C B listZip. B repeat. I.... I.... I...... C B C. B B B.. C B B. B listZip. I... B repeat. I..... I........ C B S. B B S.. B B B C... B B B B S.... B B B B B listAddFront..... C B C. B B C.. B B B C... B B B B B.... C B C. B B C.. B B B B... C B C. B B B.. C B B. I.. B listTail. I..... B listTail. I...... I...... I....... C B B. B C. B C I.. B listHead. I..... B listHead. I.....
listEquals = B S B S. B B AND.. C B B. B isEQ. B listCount. I.... B listCount. I...... C B C. B B C.. B B B listAll... B C B C. C B B. B listZip. I... I.... I..... I..
strEquals = listEquals isEQ.
listMerge = B Y. B B S B S. C B B. B IF. B listIsEmpty. I.... I..... B B S B S. B C B IF. B listIsEmpty. I.... I..... C B S. B B S.. B B B S... C B B. B S. B B S.. B B B IF... C B C. B B B.. C B B. I.. B listHead. I..... B listHead. I....... C B S. B B C.. B B B listAddFront... C B C. B B B.. C B B. I.. B listTail. I..... I..... B listHead. I....... C B C. B B S.. B B B listAddFront... C B C. B B B.. C B B. I.. I.... B listTail. I...... B listHead. I......
listSort = B Y. C B C. B B S.. B B S B IF. C B isGT. B listCount. I... 1..... C B C. B B S.. C B S. B B S.. B B B S... C B B. B B. B B. B listMerge. I..... C B B. B B. I... C B B. B listTake. I... I....... C B B. B B. I... C B B. B listSkip. I... I...... C B Div. B listCount. I... 2...... I..
intSort = listSort isLT.
listElementAt = B B listHead.. C B B. B listSkip. I... I..
strIsEmpty = listIsEmpty
strIsNotEmpty = B NOT. strIsEmpty.
strHead = listHead
strTail = listTail
strEmpty = listEmpty
strAddFront = listAddFront
strAddBack = listAddBack
strCons = listCons
strSkip = listSkip
strTake = listTake
strReturn = listReturn
strWhere = listWhere
listJoin = S B B. C B IF. B listIsEmpty. I... listEmpty... C B B. S B foldl. B listTail. I... B listHead. I.... C B C. B B B.. B B listCons.. B C B listCons. I... I..... I...
strJoin = S B B. C B IF. B strIsEmpty. I... strEmpty... C B B. S B foldl. B listTail. I... B listHead. I.... C B C. B B B.. B B strCons.. B C B strCons. I... I..... I...
strConss = C B strJoin. I.. "".
Nats0 = unfold zero. Succ.
Nats = unfold one. Succ.
zeroes = repeat 0.
ByteVals = listTake Nats0. 256.
toBinSeq = C B listMap. C B listTakeWhile. C B unfold. I.. C Div. 2.... B NOT. isZero.... C Mod. 2..
fromBinSeq = C C B foldl. C C B listZip. I.. Nats0.. C B B. B Mul. I... B Pow 2.. I..... 0.. Add.
Xor = B B fromBinSeq.. C B C. C B C. C B B. B listZipLonger. B toBinSeq. I.... B toBinSeq. I.... 0... C B C. B B Mod.. C B B. B Add. I... I.... 2...
isAlpha = B ORs. S B listAddFront. S B listAddFront. B listAddFront listEmpty.. C B isEQ. I.. 95.... S B AND. C B isGT. I.. 96... C B isLT. I.. 123..... S B AND. C B isGT. I.. 64... C B isLT. I.. 91....
Alpha = strWhere ByteVals. isAlpha.
isNum = S B AND. C B isGT. I.. 47... C B isLT. I.. 58..
Num = strWhere ByteVals. isNum.
isAlphaNum = S B OR. B isAlpha. I... B isNum. I..
AlphaNum = strCons Alpha. Num.
isWhiteSpace = C B isLT. I.. 34.
WhiteSpace = strWhere ByteVals. isWhiteSpace.
NewLine = strAddFront strReturn 10.. 13.
halt = Y C B S. C B C. B C B IF. I... I... I... I..
fak = C C B foldl. B listTake Nats.. I... one.. Mul.
xstrFromNat = Y B S B S. B C B IF. B isZero. I.... I.... C B C. B B S.. C B B. B B. I... C B B. B strAddFront. I... B Add 48.. C B Mod. I.. 10....... C B Div. I.. 10....
strFromN = S C B IF. B isZero. I... strReturn 48... B xstrFromNat strEmpty.. I..
strFromNs = C B listBind. I.. C B strAddBack. B strFromN. I... 32..
strFromZ = S S B IF. B ZisNeg. I... C B strAddFront. B strFromN. B ZabsN. I.... 45... B strFromN. B ZabsN. I...
strToN = C C B foldl. I.. 0.. C B B. B Add. C B Mul. I.. 10.... C B Sub. I.. 48...
strFromB = C C B IF. I.. "TRUE".. "FALSE".
strFromS = B strConss. C B listAddFront. B listAddFront listAddFront listEmpty. strReturn 96.... I... strReturn 96...
strFromPair = B B B strConss... C B C. B B C.. B B B listAddFront... B C B S. B B listAddFront.. C B C. B B listAddFront.. B B listAddFront listAddFront listEmpty. ")".... C B B. I.. B snd. I...... " ; "..... C B B. I.. B fst. I....... "("..
listCutAt = Y B S B S. S B C. B B IF.. S B B. B OR. B listIsEmpty. I.... B C I.. B listHead. I...... B makePair listEmpty.. I..... C B S. B B C.. B B B changeFst... C B C. B B B.. C B B. I.. B listTail. I..... I..... B C B listAddFront. I... B listHead. I.....
strFromSS = C C B foldl. I.. strEmpty.. C B B. B strCons. I... C B strAddBack. I.. 10...
xlistSplitAt = C B B. B unfold. C B listCutAt. I.. K TRUE..... C B C. B B changeSnd.. B C B listCutAt. B snd. I.... I.... C B listSkip. I.. one...
listSplitAt = C B C. B B listBind.. C B C. B B listCutAt.. C B C. B B listSkip.. C B B. B xlistSplitAt. I... I.... one.... B listIsEmpty. B snd. I...... B listReturn. B snd. I...
listContains = C B B. B B. B listAny. I.... C B C. B B B.. B C I.. I.... I..
strContains = C B C. C B B. B listContains. I... I... isEQ.
listRepeat = C B C. B B listBind.. B C B listTake. B repeat. I.... I.... I.
strBurst = C B listMap. I.. B listReturn. I..
strTrim = B reverse. C B listSkipWhile. B reverse. C B listSkipWhile. I.. isWhiteSpace.... isWhiteSpace..
strCutAt = listCutAt
maybeReturn = makePair TRUE.
maybeNothing = makePair FALSE. I.
maybeHasValue = fst
maybeGetValue = snd
maybeBind = C B C. S B B. B IF. B maybeHasValue. I.... B C I.. B maybeGetValue. I..... maybeNothing.
maybeMap = C B B. B maybeBind. I... B B maybeReturn.. I..
maybeAlternative = C B B. S B IF. B maybeHasValue. I... I... I.
maybeTryGetValue = B B maybeGetValue.. C B B. B maybeAlternative. I... B maybeReturn. I...
strFromMaybe = C B C. B S B IF. B maybeHasValue. I.... B B strCons "Just "... C B B. I.. B maybeGetValue. I...... "Nothing".
parseReturn = B B maybeReturn.. B C B makePair. I... I..
parseFail = K maybeNothing.
parseOperation = B C B maybeMap. I... B C B changeSnd. I... I..
parseBindOperation = B C B B. B parseOperation. I.... C B B. I.. I..
parsePipe = C B B. B C. B B maybeBind.. C B B. I.. I..... C B S. C B B. I.. B snd. I.... B fst. I...
parseBind = B C B B. B C. B B maybeBind.. C B B. I.. I...... C B B. B S. B B parseOperation.. C B B. I.. B snd. I...... C B B. I.. B fst. I....
parseBindDiscard = parseBind K.
parseBindOverride = parseBind K I..
parseBindPair = parseBind makePair.
parseCharIf = C B S. C B S. B B IF.. B S B AND. B NOT. B listIsEmpty. I..... C B B. I.. B listHead. I...... S B parseReturn. B listHead. I... B listTail. I..... B parseFail. I..
parseCharX = B parseCharIf. C B C. C B B. B listContains. I... I... isEQ..
parseChar = B parseCharIf. B isEQ. I..
parseString = C C B foldl. C B listMap. I.. parseChar... parseReturn strEmpty... parseBind strAddBack..
parseUntil = B B S B parseReturn. B fst. I... B snd. I.... B C B strCutAt. I... I..
parseWhile = B parseUntil. B B NOT.. I..
parseWhileMinOne = B S C B S. B C B IF. B strIsEmpty. B snd. B maybeGetValue. I...... B parseFail. I.... I... C B B. B parseWhile. I... I..
parseOption = C B B. B S. B B maybeAlternative.. C B B. I.. I..... C B B. I.. I..
parseOptions = Y B S B B. C B IF. B listIsEmpty. I... maybeNothing.... B S B S. B B maybeAlternative.. C B B. B listHead. I... I..... C B C. B B B.. C B B. I.. B listTail. I..... I....
parseWhitespace = parseWhile isWhiteSpace.
parseWithWhitespace = C B parseBindDiscard. B parseBindOverride parseWhitespace.. I... parseWhitespace.
parseToken = parseBind B C B strAddFront. I... I.. parseCharIf isAlpha.. parseWhile isAlphaNum..
parseNumber = parseBindOperation parseWhileMinOne isNum.. strToN.
parseDump = B strFromMaybe. B strFromPair strFromS.. I..
parseAccept = B C B maybeBind. I... C B C. C B S. B B IF.. C B B. I.. B fst. I..... B maybeReturn. B snd. I..... maybeNothing..
parseAcceptAll = parseAccept K TRUE..
parseAcceptFullyConsumed = parseAccept listIsEmpty.
parseWhileSuccessfulInternal = Y C B S. B B S.. C B C. B B B.. B B C.. B B S B IF. B maybeHasValue. I..... B B S B C B changeSnd. I... B C B listAddFront. I... B snd. B maybeGetValue. I....... C B C. B B B.. C B B. I.. I.... B fst. B maybeGetValue. I......... C B makePair. I.. listEmpty..... C B B. I.. I...
parseWhileSuccessful = B B maybeReturn.. C B B. B parseWhileSuccessfulInternal. I... I..
mapCreate = C B makePair. I.. listEmpty.
mapGetAll = S B B. B listWhere. B snd. I.... C B C. B B B.. C B B. B fst. I... I.... B fst. I...
mapHasKey = C B C. B B listAny.. C B B. B mapGetAll. I... I.... K TRUE..
mapCount = B listCount. snd.
mapAdd = C B B. B B. B changeSnd. I.... B B C B listAddFront. I.... C B B. B makePair. I... I...
mapRemove = S B B. B changeSnd. I... B B C B listWhere. I.... B B B NOT... C B C. B B B.. C B B. B fst. I... I.... B fst. I.....
mapSet = C B C. B B B.. C B S. B B mapAdd.. C B B. B mapRemove. I... I.... I.... I.
mapGet = B B snd.. B B listHead.. C B B. B mapGetAll. I... I...
idfCreate = mapCreate
idfHandle = S B S. S B S. B B IF.. C B B. B mapHasKey. I... I.... S B B. B makePair. I... C B B. B mapGet. I... I..... S B C. C B C. B B S.. B B B makePair... C B C. B B B.. C B B. B mapAdd. I... I.... I..... I... B mapCount. I...
idfHandleX = C B C. B C B foldl. I... C B makePair. I.. listEmpty.... S B B. B S B makePair. B fst. I.... C B B. B listAddBack. B snd. I.... B snd. I..... C B B. B idfHandle. B fst. I.... I...
idfCount = mapCount
listDistinct = B B snd.. C B C. C B B. B foldl. I... C B makePair. B idfCreate. I... listEmpty.... S B S. B B S B makePair. B fst. I..... S B C. B B C.. S B B. B C. B B IF.. B C B isEQ. B snd. I.... B idfCount. B fst. I....... C B B. B listAddBack. B snd. I.... I..... B snd. I..... C B B. B idfHandle. B fst. I.... I....
newLine = strReturn 10.
empty = strReturn 32.
diff = S B S. S B S. B B IF.. C B B. B isLT. I... I.... B C B Sub. I... I.... C B B. B Sub. I... I..
gDrawL = C B B. B B. B listBind. B listTake Nats0.. I..... B C B C. C B B. I.. I.... I..
gDraw = B C B B. B listBind. B listTake Nats0.. I..... C B C. B B C.. B B B listCons... C B B. B C. C B B. B gDrawL. I... I.... I..... newLine..
gCanvas = K K empty..
gOverlay = C B C. B B B.. B B S.. B B B S... C B B. B C. B B C.. B B B IF... C B C. B B B.. C B B. I.. I.... I...... B listReturn. I....... C B C. B B B.. C B B. I.. I.... I..
gPixel = C B C. B B B.. B B gOverlay.. C B B. B C. B B B.. B B AND.. B C B isEQ. I... I...... B C B isEQ. I... I...... I.
gCircle = C B C. B B C.. B B B B... B B B gOverlay... B B C B B. B B. B isGT. C B Pow. I.. 2....... C B B. B C. B B B.. B B Add.. C B C. B B Pow.. B C B diff. I... I.... 2...... C B C. B B Pow.. B C B diff. I... I.... 2........ I.
makeTriple = C B C. B B B.. B B C.. C B B. B C. B C I.. I.... I..... I.
tfst = C I. B K. B K. I...
tsnd = C I. K B K. I...
ttrd = C I. K K I...
tchangeFst = S B C. S B C. B B makeTriple.. B C I.. B tfst. I..... B tsnd. I.... B ttrd. I..
tchangeSnd = S B C. S B B. B makeTriple. B tfst. I.... B C I.. B tsnd. I..... B ttrd. I..
tchangeTrd = S B B. S B makeTriple. B tfst. I... B tsnd. I.... B C I.. B ttrd. I...
beanEmpty = K maybeNothing.
beanSet = B C B C. B B S.. C B B. B C. B B IF.. C B B. B strEquals. I... I..... B maybeReturn. I...... C B B. I.. I..
beanTryGet = C B B. I.. I.
beanGet = B B maybeGetValue.. C B B. I.. I..
beanHas = B B maybeHasValue.. C B B. I.. I..
seqEmpty = makePair 0. I.
seqLength = fst
seqGet = snd
seqSet = C B B. B B. B changeSnd. I.... C B C. B B B.. B B S.. C B B. B C. B B IF.. C B B. B isEQ. I... I..... I..... C B B. I.. I...
seqAddFront = S B B. B makePair. B Succ. B seqLength. I..... B C B S. B C B IF. B isZero. I.... I.... C B B. B seqGet. I... B Pred. I....
seqAddBack = S B B. B makePair. B Succ. B seqLength. I..... S B C. B B S.. C B B. B C. B B IF.. B C B isEQ. I... B seqLength. I...... I.... C B B. B seqGet. I... I...
seqConcat = S B S. B B makePair.. C B B. B Add. B seqLength. I.... B seqLength. I..... S B B. B S. S B S. B B IF.. B C B isLT. I... B seqLength. I..... C B B. B seqGet. I... I..... B C B B. B seqGet. I.... B C B Sub. I... B seqLength. I.....
seqRangeUnsafe = B B C B makePair. I.... C B B. B B. B seqGet. I.... B C B Sub. I... I...
seqRange = S B S. B B B.. C B B. B seqRangeUnsafe. I... I.... B B C B Min. I.... C B B. B Sub. B seqLength. I.... I...
seqToList = S B listMap. B listTake Nats0.. B seqLength. I.... C B B. B seqGet. I... I..
listToSeq = C C B foldr. I.. seqEmpty.. C B B. B seqAddFront. I... I..
listHeadOrDefault = S B C. C B B. B IF. B listIsEmpty. I.... I... B listHead. I..
_switchCond = C B C. B B B.. C B B. B foldr. I... I.... C B B. B C. C B S. B B IF.. C B B. I.. B fst. I..... B snd. I..... I..
switchCond = B C B C. C B B. B _switchCond. I... I.... I.
switch = C B C. B B C.. B B B B... C B B. B C. B B switchCond.. B C I.. I..... I..... I.
switchN = C B C. B B B.. C B C. C B B. B switch. I... I... isEQ.... I.
getFirstConsumeMoreDeferred = B C I.. B S B Y. C B B. B S. B C B IF. B isZero. I.... I.... B B K.. C B B. I.. B Pred. I....... C B B. I.. I...
getFirstConsumeMore = B getFirstConsumeMoreDeferred. B K. I..
_eCharBrOpen = strHead "(".
_eCharBrClose = strHead ")".
_eCharSqBrOpen = strHead "[".
_eCharSqBrClose = strHead "]".
_eCharComma = strHead ",".
_eCharAbstr = strHead "\".
_eCharAssign = 61
_eCharComment = 39
_eStrColon = strReturn 58.
_eIsQuot = S B OR. C B isEQ. I.. 34... C B isEQ. I.. 96..
_eIsNewLine = S B OR. C B isEQ. I.. 10... C B isEQ. I.. 13..
tokenParenOpen = C I. 0.
tokenParenClose = C I. 1.
tokenAbstraction = C I. 2.
tokenAssign = C I. 3.
tokenSqBracketOpen = C I. 4.
tokenSqBracketClose = C I. 5.
tokenComma = C I. 6.
tokenLiteral = B C C I. 10... I.
tokenConstS = B C C I. 11... I.
tokenConstN = B C C I. 12... I.
tokenComment = B C C I. 13... I.
token_VarCount = C C B IF. C B isLT. I.. 10... 0.. 1.
token_Type = getFirstConsumeMoreDeferred token_VarCount.
token_String = S B S C B IF. C I. 0... "<PAR_OPEN>"... B S C B IF. C I. 1... "<PAR_CLOSE>"... B S C B IF. C I. 2... "<ABSTRACT>"... B S C B IF. C I. 3... "<ASSIGN>"... B S C B IF. C I. 4... "<SQBR_OPEN>"... B S C B IF. C I. 5... "<SQBR_CLOSE>"... B S C B IF. C I. 6... "<COMMA>"... S B S. B C B IF. C I. 10.... B strConss. C B listAddFront. B listAddFront listAddFront listEmpty. ")>"... C I. K I..... "<LITERAL("..... S B S. B C B IF. C I. 11.... B strConss. C B listAddFront. B listAddFront listAddFront listEmpty. ")>"... C I. K I..... "<CONSTS("..... C B S. B C B IF. C I. 12.... B strConss. C B listAddFront. B listAddFront listAddFront listEmpty. ")>"... B strFromN. C I. K I...... "<CONSTN("..... C C B IF. C I. 13... "<COMMENT>".. "<!!!UNKNOWN!!!>"............ B isEQ. B token_Type. I...
token_String_list = C B strJoin. C B listMap. I.. token_String... " ".
eatParenOpen = parseBindOperation parseChar _eCharBrOpen.. K tokenParenOpen..
eatParenClose = parseBindOperation parseChar _eCharBrClose.. K tokenParenClose..
eatSqBracketOpen = parseBindOperation parseChar _eCharSqBrOpen.. K tokenSqBracketOpen..
eatSqBracketClose = parseBindOperation parseChar _eCharSqBrClose.. K tokenSqBracketClose..
eatComma = parseBindOperation parseChar _eCharComma.. K tokenComma..
eatAbstraction = parseBindOperation parseChar _eCharAbstr.. K tokenAbstraction..
eatAssign = parseBindOperation parseChar _eCharAssign.. K tokenAssign..
eatLiteral = parseBindOperation parseOption parseToken. parseString ":"... B tokenLiteral. I..
eatConstS = parseBindOperation parseBindOverride parseCharIf _eIsQuot.. parseBindDiscard parseUntil _eIsQuot.. parseCharIf _eIsQuot.... B tokenConstS. I..
eatConstN = parseBindOperation parseNumber. B tokenConstN. I..
eatComment = parseBindOperation parseBindOverride parseChar _eCharComment.. parseUntil _eIsNewLine... B tokenComment. I..
eatSomething = parseWithWhitespace parseOptions listAddFront listAddFront listAddFront listAddFront listAddFront listAddFront listAddFront listAddFront listAddFront listAddFront listAddFront listEmpty. eatComma.. eatSqBracketClose.. eatSqBracketOpen.. eatComment.. eatAssign.. eatConstN.. eatConstS.. eatLiteral.. eatAbstraction.. eatParenClose.. eatParenOpen...
token_Process = B parseAcceptFullyConsumed. parseWhileSuccessful eatSomething..
token_Run = B strFromMaybe I.. C B maybeMap. B token_Process. I... token_String_list..
syntaxLiteral = B C C I. 0... I.
syntaxConstN = B C C I. 1... I.
syntaxConstS = B C C I. 2... I.
syntaxList = B C C I. 3... I.
syntaxAbstraction = C B B. B C. B C C I. 10... I.... I.
syntaxApplication = C B B. B C. B C C I. 11... I.... I.
syntaxAssignment = C B B. B C. B C C I. 12... I.... I.
syntax_VarCount = C C B IF. C B isLT. I.. 10... 1.. 2.
syntax_Type = getFirstConsumeMoreDeferred syntax_VarCount.
syntax_String = Y C B C. B S B switchN. B syntax_Type. I.... C B S. B B listAddFront.. C B S. B B listAddFront.. C B S. B B listAddFront.. S B S. B B listAddFront.. S B S. B B listAddFront.. S B S. B B listAddFront.. B B listAddFront listEmpty... B B makePair 12... B B strConss.. C B C. B B listAddFront.. C B S. B B listAddFront.. C B C. B B listAddFront.. B B listAddFront listAddFront listEmpty. ")".... C B B. I.. C I. K K I........ ", ".... C I. K B K. I....... "assign("....... B B makePair 11... B B strConss.. C B C. B B listAddFront.. S B S. B B listAddFront.. C B C. B B listAddFront.. B B listAddFront listAddFront listEmpty. ")".... C B B. I.. C I. K K I........ ", ".... C B B. I.. C I. K B K. I........ "apply("....... B B makePair 10... B B strConss.. C B C. B B listAddFront.. C B S. B B listAddFront.. C B C. B B listAddFront.. B B listAddFront listAddFront listEmpty. ")".... C B B. I.. C I. K K I........ ", ".... C I. K B K. I....... "abstract("....... B B makePair 3... B B strConss.. C B C. B B listAddFront.. B B listAddFront listAddFront listEmpty. ")".... C B C. B B strJoin.. B C B listMap. C I. K I..... I.... ", "..... "list("....... B makePair 2.. B strConss. C B listAddFront. B listAddFront listAddFront listEmpty. ")"... C I. K I..... "consts("....... B makePair 1.. B strConss. C B listAddFront. B listAddFront listAddFront listEmpty. ")"... B strFromN. C I. K I...... "constn("....... B makePair 0.. B strConss. C B listAddFront. B listAddFront listAddFront listEmpty. ")"... C I. K I..... "literal("....... "!!!unknown!!!"..
syntax_String_list = C B strJoin. C B listMap. I.. syntax_String... "; ".
token_Parse = B parseCharIf. B C B isEQ. B token_Type. I.... I..
cstrSyntaxLiteral = parseBindOperation token_Parse 10.. B listReturn. B syntaxLiteral. C I. K I.....
cstrSyntaxConst = parseOption parseBindOperation token_Parse 11.. B listReturn. B syntaxConstS. C I. K I...... parseBindOperation token_Parse 12.. B listReturn. B syntaxConstN. C I. K I......
cstrSyntaxComment = parseBindOperation token_Parse 13.. K listEmpty..
cstrSyntaxAbstract = B parseBindOverride token_Parse 2... B parseBind B B listReturn.. C B B. B syntaxAbstraction. C I. K I..... I... token_Parse 10... I..
cstrSyntaxAssignment = B parseBind B B listReturn.. C B B. B syntaxAssignment. C I. K I..... I... parseBindDiscard token_Parse 10.. token_Parse 3.... I.
cstrSyntaxNested = B parseBindOverride token_Parse 0... C B parseBindDiscard. C B parseBindOperation. I.. listReturn... token_Parse 1...
cstrSyntaxList = B parseBindOverride token_Parse 4... C B parseBindDiscard. C B parseBindOperation. S B parseBind B C B listAddFront. I... I... I.. B parseWhileSuccessful. B parseBindOverride token_Parse 6... I..... B listReturn. B syntaxList. I..... token_Parse 5...
cstrSyntaxSingle = B parseOptions. C B listAddFront. C B listAddFront. S B listAddFront. S B listAddFront. C B listAddFront. B listAddFront listEmpty.. B cstrSyntaxList. I.... cstrSyntaxComment... B cstrSyntaxAbstract. I.... B cstrSyntaxNested. I.... cstrSyntaxConst... cstrSyntaxLiteral..
cstrSyntaxApplication = C B parsePipe. B parseWhileSuccessful. B cstrSyntaxSingle. I.... B S C B IF. B listIsEmpty. I... parseFail.. B parseReturn. C S B foldl. B listTail. I... B listHead. I... C B B. B syntaxApplication. I... I..... C B listBind. I.. I...
cstrSyntaxEverything = parseWhileSuccessful Y cstrSyntaxApplication..
syntax_Process = B parseAcceptFullyConsumed. cstrSyntaxEverything.
syntaxResultsToString = strFromMaybe C B strJoin. C B listMap. I.. B strFromN. syntax_Type.... ", "..
syntaxResultToString = strFromMaybe B B strFromN. syntax_Type.. I..
syntax_Run = B strFromMaybe I.. C B maybeMap. C B maybeBind. B token_Process. I... syntax_Process... syntax_String_list..
nativeLiteral = B C C I. 0... I.
nativeConstN = B C C I. 1... I.
nativeConstS = B C C I. 2... I.
nativeApplication = C B B. B C. B C C I. 10... I.... I.
nativeAssignment = C B B. B C. B C C I. 11... I.... I.
native_VarCount = C C B IF. C B isLT. I.. 10... 1.. 2.
native_Type = getFirstConsumeMoreDeferred native_VarCount.
native_String = Y C B S. B S B S. B C B IF. C I. 0.... B strConss. C B listAddFront. B listAddFront listAddFront listEmpty. ")"... C I. K I..... "literal("...... B S B S. B C B IF. C I. 1.... B strConss. C B listAddFront. B listAddFront listAddFront listEmpty. ")"... B strFromN. C I. K I...... "constn("...... B S B S. B C B IF. C I. 2.... B strConss. C B listAddFront. B listAddFront listAddFront listEmpty. ")"... C I. K I..... "consts("...... S B S. B B S.. B B C B IF. C I. 10..... B B strConss.. C B C. B B listAddFront.. S B S. B B listAddFront.. C B C. B B listAddFront.. B B listAddFront listAddFront listEmpty. ")".... C B B. I.. C I. K K I........ ", ".... C B B. I.. C I. K B K. I........ "apply("...... C B C. B B C.. B B C B IF. C I. 11..... B B strConss.. C B C. B B listAddFront.. C B S. B B listAddFront.. C B C. B B listAddFront.. B B listAddFront listAddFront listEmpty. ")".... C B B. I.. C I. K K I........ ", ".... C I. K B K. I....... "assign("...... "!!!unknown!!!"....... B isEQ. B native_Type. I....
native_String_list = C B strJoin. C B listMap. I.. native_String... "; ".
nativeI = nativeLiteral "I".
nativeK = nativeLiteral "K".
nativeB = nativeLiteral "B".
nativeC = nativeLiteral "C".
nativeS = nativeLiteral "S".
nativeListEmpty = nativeLiteral "listEmpty".
nativeListAddFront = nativeLiteral "listAddFront".
isNativeC = S B AND. B isEQ 0.. B native_Type. I.... B strEquals "C".. C I. K I....
nativeContainsLit = Y C B S. B B C.. B S B S. B B S.. B B C B IF. C I. 0..... B C B strEquals. I... C I. K I........ C B C. B B C.. B B B C... B B B C B IF. C I. 10...... S B S. B B S.. B B B OR... C B C. B B B.. C B B. I.. C I. K B K. I....... I..... C B C. B B B.. C B B. I.. C I. K K I....... I....... FALSE..... B isEQ. B native_Type. I....
optimizeNative = I
_syntaxToNative = Y C B C. B S B switchN. B syntax_Type. I.... C B S. B B listAddFront.. C B S. B B listAddFront.. C B S. B B listAddFront.. S B S. B B listAddFront.. S B S. B B listAddFront.. S B S. B B listAddFront.. B B listAddFront listEmpty... B B makePair 10... B S B Y C B S. B B S.. B B S B IF. C B isEQ. B native_Type. I... 10..... C B C. B B S.. C B C. B B S.. S B S. B B B.. B B S.. B B B S... B S B S. B B B.. B B IF.. B C B nativeContainsLit. I... I...... S B S. B B S.. B B B S... B S B B. B S. B B IF.. B C B nativeContainsLit. I... I...... S B S. B B C.. B B B B... B B B nativeApplication... B B B nativeApplication nativeS.... C B C. B B B.. C B B. I.. I.... I....... C B C. B B B.. C B B. I.. I.... I....... C B C. B B C.. B B B B... B B B nativeApplication... B B B nativeApplication nativeC.... C B C. B B B.. C B B. I.. I.... I....... I........ C B C. B B B.. B B C.. B B B C... B S B B. B S. B B IF.. B C B nativeContainsLit. I... I...... B B S B S. B C B IF. B isEQ 0.. B native_Type. I..... I..... B B C B B. B nativeApplication. B nativeApplication nativeB.. I...... C B C. B B B.. C B B. I.. I.... I......... B nativeApplication nativeK.. I...... C I. K B K. I....... C I. K K I........ C B S. C B C. B B IF.. B C B nativeContainsLit. I... I.... nativeI... B nativeApplication nativeK.. I..... C I. K B K. I...... C B B. I.. C I. K K I.......... B B makePair 12... B S B nativeAssignment. C I. K B K. I...... C B B. I.. C I. K K I.......... B B makePair 11... S B S. B B nativeApplication.. C B B. I.. C I. K B K. I....... C B B. I.. C I. K K I.......... B B makePair 3... B C C B foldr. C I. K I.... nativeListEmpty... B C B B. B nativeApplication. B nativeApplication nativeListAddFront.. I..... C B B. I.. I........ B makePair 2.. B nativeConstS. C I. K I........ B makePair 1.. B nativeConstN. C I. K I........ B makePair 0.. B nativeLiteral. C I. K I........ I..
syntaxToNative = B optimizeNative. _syntaxToNative.
nativeToExe = Y C B C. B S B switchN. B native_Type. I.... C B S. B B listAddFront.. C B S. B B listAddFront.. C B S. B B listAddFront.. S B S. B B listAddFront.. B B listAddFront listEmpty... B B makePair 11... B B strConss.. C B S. B B listAddFront.. C B C. B B listAddFront.. C B C. B B listAddFront.. C B C. B B listAddFront.. B B listAddFront listEmpty... C B B. I.. C I. K K I........ " ".... strReturn _eCharAssign..... " ".... C I. K B K. I.......... B B makePair 10... B B strConss.. S B S. B B listAddFront.. C B C. B B listAddFront.. B B listAddFront listAddFront listEmpty. ".".... C B B. I.. C I. K K I........ " ".... C B B. I.. C I. K B K. I........... B makePair 2.. C B strAddBack. C B strAddFront. C I. K I.... 34... 34...... B makePair 1.. B strFromN. C I. K I........ B makePair 0.. C I. K I....... "<UNKNOWN_NATIVE>"..
nativeToObj = Y C B S. B B C.. B B S B switchN. B native_Type. I..... C B S. B B S.. B B B listAddFront... C B S. B B S.. B B B listAddFront... C B S. B B S.. B B B listAddFront... S B S. B B S.. B B B listAddFront... B B B listAddFront listEmpty.... B B B makePair 11.... B S B S. C B B. B B S B makePair. I.... B C B C. B B S.. C B B. B C. B B IF.. C B B. B strEquals. I... I..... B maybeReturn. I...... C B B. I.. I..... C I. K B K. I....... B B B fst... C B C. B B B.. C B B. I.. I.... C I. K K I............ B B B makePair 10.... C B S. B B C.. B B B makePair... S B S. B B S.. B B B fst... C B C. B B B.. C B B. I.. I.... C I. K B K. I........ B B B fst... C B C. B B B.. C B B. I.. I.... C I. K K I.......... I....... B B makePair 2... B C B makePair. C I. K I..... I....... B B makePair 1... B C B makePair. C I. K I..... I....... B B makePair 0... S B C. B B makePair.. B B maybeGetValue.. C B B. I.. C I. K I....... I....... B makePair I.. I...
native_Run = B strFromMaybe I.. C B maybeMap. C B maybeMap. C B maybeBind. B token_Process. I... syntax_Process... C B listMap. I.. syntaxToNative.... native_String_list..
native_Process = B maybeReturn. C B listMap. I.. syntaxToNative..
nativeTemp = B maybeGetValue. C B maybeMap. C B maybeBind. B token_Process. I... syntax_Process... B fst. B nativeToObj I.. B listHead. I.....
eatAll = C B maybeMap. C B maybeBind. B token_Process. I... syntax_Process... C B strJoin. C B listMap. I.. B nativeToExe. B syntaxToNative. I..... "; "..
run2 = B C B maybeMap. C B maybeBind. B token_Process. I... syntax_Process.... B B fst.. C B B. B nativeToObj. I... B syntaxToNative. B listHead. I.....
evalNumber = parseWithWhitespace parseNumber.
evalProduct = Y C B parseOption. B parseBind Mul. evalNumber.. B parseBindOverride parseChar strHead "*".... I.... evalNumber..
evalSum = Y C B parseOption. B parseBind Add. evalProduct.. B parseBindOverride parseChar strHead "+".... I.... evalProduct..
eval = B strFromN. C B maybeTryGetValue. B parseAcceptFullyConsumed. B evalSum. I.... 1337..
million = Mul 1000. 1000.
millionS = strFromN million.
testCount = 83
test0 = TRUE
test1 = I TRUE.
test2 = K TRUE. FALSE.
test3 = S K I.. I. TRUE.
test4 = NOT FALSE.
test5 = B NOT. NOT. TRUE.
test6 = OR TRUE. FALSE.
test7 = NOT OR FALSE. FALSE..
test8 = AND TRUE. TRUE.
test9 = NOT AND TRUE. FALSE..
test10 = IMPLIES FALSE. FALSE.
test11 = IMPLIES FALSE. TRUE.
test12 = IMPLIES TRUE. TRUE.
test13 = NOT IMPLIES TRUE. FALSE..
test14 = EQ FALSE. FALSE.
test15 = EQ TRUE. TRUE.
test16 = isZero 0.
test17 = NOT isZero 1..
test18 = isEQ 42. 42.
test19 = NOT isEQ 42. 43..
test20 = isEQ 1. Succ 0..
test21 = isEQ 43. Add 23. 20..
test22 = isEQ 69. Mul 3. 23..
test23 = isEQ 32. Pow 2. 5..
test24 = isEQ 31. Pred 32..
test25 = isEQ 65. Sub 101. 36..
test26 = isEQ 3. Div 63. 16..
test27 = isEQ 3. Mod 91. 4..
test28 = isLTE 3. 3.
test29 = isLTE 3. 4.
test30 = NOT isLTE 3. 2..
test31 = isGTE 4. 3.
test32 = isLT 3. 4.
test33 = NOT isLT 3. 3..
test34 = isGT 4. 3.
_test35f = makePair 45. 23.
test35 = isEQ 45. fst _test35f..
test36 = isEQ 23. snd _test35f..
_test37f = "Aa"
test37 = listIsNotEmpty _test37f.
test38 = NOT listIsEmpty _test37f..
test39 = isEQ 65. listHead _test37f..
test40 = isEQ 97. B listHead. listTail. _test37f..
_test41f = listAddFront listEmpty. 66.
test41 = isEQ 66. listHead _test41f..
test42 = isEQ 2. listCount _test37f..
test43 = isEQ 97. B listHead. reverse. _test37f..
test44 = isEQ 3. listCount listCons _test37f. _test41f...
test45 = isEQ 1. listCount listReturn 32...
test46 = isEQ 3. listCount listAddBack _test37f. 49...
test47 = strEquals _test37f. "Aa".
test48 = NOT strEquals _test37f. "AA"..
test49 = strEquals "asd". listTake "asdqwe". 3..
test50 = strEquals "asd". listTakeWhile "asdqwe". B NOT. C B isEQ. I.. listHead "q".....
test51 = strEquals "bte". listMap "asd". Succ..
test52 = strEquals "ade". listWhere "asdqwe". C B isLTE. I.. listHead "e"....
test53 = strEquals "qwe". listSkip "asdqwe". 3..
test54 = strEquals "qwe". listSkipWhile "asdqwe". B NOT. C B isEQ. I.. listHead "q".....
test55 = listAny "qwe". C B isEQ. I.. listHead "w"...
test56 = NOT listAny "asd". C B isEQ. I.. listHead "w"....
test57 = listAll "qwe". C B isGT. I.. 65..
test58 = NOT listAll "qwe". C B isGT. I.. 110...
test59 = strEquals "bte". listZip "asd". repeat 1.. Add..
test60 = isEQ 65. listElementAt "asdAqwe". 3..
test61 = isEQ 1. listHead Nats..
test62 = isEQ 0. listHead Nats0..
test63 = isEQ 0. listHead ByteVals..
test64 = isEQ 256. listCount ByteVals..
test65 = isEQ 435. Xor 123. 456..
test66 = isAlpha 65.
test67 = NOT isAlpha 64..
test68 = isNum listHead "0"..
test69 = NOT isNum listHead "a"...
test70 = isAlphaNum listHead "a"..
test71 = isAlphaNum listHead "0"..
test72 = NOT isAlphaNum listHead "!"...
test73 = isWhiteSpace listHead " "..
test74 = NOT isWhiteSpace listHead "a"...
test75 = isEQ 720. fak 6..
test76 = strEquals "23". strFromN 23..
test77 = strEquals "(12 ; 13)". strFromPair strFromN. strFromN. makePair 12. 13...
test78 = strEquals "(asd ; qwe)". strFromPair I. I. listCutAt "asdqwe". C B isEQ. I.. listHead "q".....
test79 = strContains "asd". listHead "s"..
test80 = NOT strContains "asd". listHead "w"...
test81 = strEquals "asd". strTrim "   asd   "..
test82 = TRUE
tfac1 = B snd. C B makePair. I.. 1..
tfac2 = K 1.
tval1 = tfac1 I.
tval2 = tfac2 I.
tswitch = C C B switchN. I.. listAddFront listAddFront listAddFront listAddFront listAddFront listEmpty. makePair 4. "e"... makePair 3. "d"... makePair 2. "c"... makePair 1. "b"... makePair 0. "a".... "x".
lengthyOp = C C B IF. B strIsEmpty. B :. I.... I.. I.
calledOften1 = C B B. B lengthyOp. I... I.
calledOften2 = B C B B C B lengthyOp. I... I.. I... I.
scenario1 = B foldl listTake Nats. 5.. "0".. B B K.. B B calledOften1 "42"... C B B. B strCons. I... I....
scenario2 = B foldl listTake Nats. 5.. "0".. B B K.. B B calledOften2 "42"... C B B. B strCons. I... I....
