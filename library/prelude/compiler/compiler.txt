'------------------'
' COMPILER SECTION '
'------------------'

'''''' TYPING

' TYPES
Type = TypeVariable uid     ' N
     | TypeAbstraction a b  ' Type Type
     | TypeIntersection a b ' Type Type

'(((d -> (c -> b)) -> ((g -> c) -> (d^g -> b))) -> ((e -> (f -> e)) -> a)) -> a
typeUa = TypeVariable 0
typeUb = TypeVariable 1
typeUc = TypeVariable 2
typeUd = TypeVariable 3
typeUe = TypeVariable 4
typeUf = TypeVariable 5
typeUg = TypeVariable 6
typeU = TypeAbstraction 
            (TypeAbstraction
                (TypeAbstraction
                    (TypeAbstraction typeUd (TypeAbstraction typeUc typeUb))
                    (TypeAbstraction (TypeAbstraction typeUg typeUc) (TypeAbstraction (TypeIntersection typeUd typeUg) typeUb))
                )
                (TypeAbstraction
                    (TypeAbstraction typeUe (TypeAbstraction typeUf typeUe))
                    typeUa
                )
            )
            typeUa

u_Type = Just typeU

typeKx = TypeAbstraction typeUe (TypeAbstraction typeUf typeUe)
typeIx = TypeAbstraction typeUe typeUe
typeSx = (TypeAbstraction
            (TypeAbstraction typeUd (TypeAbstraction typeUc typeUb))
            (TypeAbstraction (TypeAbstraction typeUg typeUc) (TypeAbstraction (TypeIntersection typeUd typeUg) typeUb))
        )

printType = \type type
                (\uid strFromN uid)
                (\a \b strConss ["(", printType a, " -> ", printType b, ")"])
                (\a \b strConss ["(", printType a, " ^ ", printType b, ")"])
printRestrictionList = \typePairList strJoin (listMap typePairList (\pair pair (\a \b strConss [printType a, " = ", printType b]))) ", "
printUnificationList = \typePairList strJoin (listMap typePairList (\pair pair (\a \b strConss [strFromN a, " => ", printType b]))) ", "
printUnificationResult = \mtypePairList strFromMaybe printUnificationList mtypePairList

_typeEnumVariables = \type type
                        (\uid listReturn uid)
                        (\a \b listConcat (_typeEnumVariables a) (_typeEnumVariables b))
                        (\a \b listConcat (_typeEnumVariables a) (_typeEnumVariables b))
typeEnumVariables = \type listDistinct (_typeEnumVariables type) isEQ

typeCountUsage = \type \uid type
                        (\uidx if(isEQ uid uidx) 1 0)
                        (\a \b add (typeCountUsage a uid) (typeCountUsage b uid))
                        (\a \b add (typeCountUsage a uid) (typeCountUsage b uid))

' strips singletons
_removeSingletons = \type \removeUidPred type
                        (\uid type)
                        (\a \b TypeAbstraction (_removeSingletons a removeUidPred) (_removeSingletons b removeUidPred))
                        (\a \b if (listAll (typeEnumVariables a) removeUidPred) b
                              (if (listAll (typeEnumVariables b) removeUidPred) a 
                              (TypeIntersection (_removeSingletons a removeUidPred) (_removeSingletons b removeUidPred))
                              )
                        )
' renumbers vars
_typeNormalize = \type \vars type
                        (\uid TypeVariable (maybeTryGetValue (listIndexOf vars isEQ uid) 1337))
                        (\a \b TypeAbstraction (_typeNormalize a vars) (_typeNormalize b vars))
                        (\a \b TypeIntersection (_typeNormalize a vars) (_typeNormalize b vars))
typeNormalize = \type (\type _typeNormalize type (typeEnumVariables type))
                      (
                        (\singletons _removeSingletons 
                            type 
                            (\uidx listAny 
                                singletons
                                (isEQ uidx)
                            )
                        ) (listWhere (typeEnumVariables type) (\uid isEQ 1 (typeCountUsage type uid)))
                      )



' offsets all variable uids by a constant (e.g. to prevent collisions) 
_typeShift = \type \offset type
                        (\uid TypeVariable (add offset uid))
                        (\a \b TypeAbstraction (_typeShift a offset) (_typeShift b offset))
                        (\a \b TypeIntersection (_typeShift a offset) (_typeShift b offset))

typeNextSafeVariable = \type foldl (typeEnumVariables (_typeShift type 1)) 0 max
typeContainsVariableUid = \uid \type listAny (typeEnumVariables type) (isEQ uid)

typeReplaceUidWithType = \uid \type \containerType containerType
                        (\uidx if(isEQ uid uidx) type containerType)
                        (\a \b TypeAbstraction (typeReplaceUidWithType uid type a) (typeReplaceUidWithType uid type b))
                        (\a \b TypeIntersection (typeReplaceUidWithType uid type a) (typeReplaceUidWithType uid type b))

typeListReplaceUidWithType = \uid \type \tlist listMap tlist (\pair pair (\a \b Pair (typeReplaceUidWithType uid type a) (typeReplaceUidWithType uid type b)))



_getSelfAppCenterHelper = \var \abs 
        TypeVariable_Dispatch
            (\uid TypeAbstraction_Dispatch
                (\a \b TypeVariable_Dispatch (\uidx if (isEQ uid uidx) (Just b) Nothing) Nothing a)
                Nothing
                abs
            )
            Nothing
            var

' Type -> Maybe Type
' (t -> <center>) ^ t
_getSelfAppCenter = \t 
        TypeIntersection_Dispatch
            (\ax \bx TypeVariable_Dispatch (k (_getSelfAppCenterHelper ax bx)) (_getSelfAppCenterHelper bx ax) ax)
            Nothing
            t

' Type -> Type -> Maybe [Pair Type Type]
' (t -> a) ^ t = (u -> b) ^ u -> c
_isFixPointComboHelper = \t1 \t2
        TypeAbstraction_Dispatch
            (\a \b
                (\m1 \m2 \a3
                    maybeBind m1
                    (\a1 
                        maybeMap m2
                        (\a2 [Pair a1 a2, Pair a1 a3])
                    )
                )
                (_getSelfAppCenter t1)
                (_getSelfAppCenter a)
                b
            )
            Nothing
            t2

fpTest1 = TypeIntersection (TypeVariable 0) (TypeAbstraction (TypeVariable 0) (TypeVariable 1))
fpTest2 = TypeAbstraction (_typeShift fpTest1 2) (TypeVariable 4)
fpTest3 = [Pair fpTest1 fpTest2]

' unify -> N -> iaType -> ibType -> otherType -> [Pair Type Type] -> Maybe Type
_intersectionSplit = \unify \nextSafeUid \ia \ib \other \c2
    maybeTryGetValue
    ( ' fix point       
        maybeMap
            (_isFixPointComboHelper (TypeIntersection ia ib) other)
            (\list unify nextSafeUid (listConcat c2 list))
    )
    ( ' el classico
        (\otherA \otherB
            maybeMap 
                (unify (mul 3 nextSafeUid) (listConcat c2 [Pair ia otherA, Pair ib otherB])) 
                i'(listConcat (listMap (typeEnumVariables other) (\uid Pair uid (TypeIntersection (TypeVariable (add uid nextSafeUid)) (TypeVariable (add uid (mul 2 nextSafeUid)))))))
        ) (_typeShift other nextSafeUid) (_typeShift other (mul 2 nextSafeUid))
    )

' N -> Type -> N -> [Pair Type Type] -> Maybe Type
_typeUnify = \breakN \interesting \nextSafeUid \c breakN 
            Nothing
            (\pred c
                (Just interesting)
                (\head \c2 head
                    (\l \r l
                        (\uid 
                            (\rContainsL \innerResult 
                                if(rContainsL) 
                                (TypeVariable_Dispatch (\uidx _typeUnify pred interesting nextSafeUid c2) Nothing r)
                                innerResult
                            ) (typeContainsVariableUid uid r) (_typeUnify pred (typeReplaceUidWithType uid r interesting) nextSafeUid (typeListReplaceUidWithType uid r c2))
                        )
                        (\a \b r
                            (\uidx if(typeContainsVariableUid uidx l) Nothing (_typeUnify pred (typeReplaceUidWithType uidx l interesting) nextSafeUid (typeListReplaceUidWithType uidx l c2)))
                            (\ax \bx _typeUnify pred interesting nextSafeUid (listConcat c2 [Pair a ax, Pair b bx]))
                            (\ax \bx _intersectionSplit (_typeUnify pred interesting) nextSafeUid ax bx l c2)
                        )
                        (\a \b r
                            (\uidx if(typeContainsVariableUid uidx l) Nothing (_typeUnify pred (typeReplaceUidWithType uidx l interesting) nextSafeUid (typeListReplaceUidWithType uidx l c2)))
                            (\ax \bx _intersectionSplit (_typeUnify pred interesting) nextSafeUid a b r c2)
                            (\ax \bx _typeUnify pred interesting nextSafeUid (listConcat c2 [Pair a ax, Pair b bx]))
                        )
                    )
                )
            )

' Type -> [Pair Type Type] -> Maybe Type
typeUnify = \interesting \c _typeUnify 40 interesting (foldl (listMap c (\pair pair (\a \b max (typeNextSafeVariable a) (typeNextSafeVariable b)))) 0 max) c

' Type -> Type -> Maybe Type
typeApply = \a \b maybeMap ((\oa \ob typeUnify (TypeVariable (add oa ob)) [Pair a (TypeAbstraction (_typeShift b oa) (TypeVariable (add oa ob)))]) (typeNextSafeVariable a) (typeNextSafeVariable b)) typeNormalize


typeErr = TypeVariable 42
typeI = maybeTryGetValue (typeApply typeU typeU) typeErr 
typeUI = maybeTryGetValue (typeApply typeU typeI) typeErr 
typeK = maybeTryGetValue (typeApply typeU typeUI) typeErr 
typeKI = maybeTryGetValue (typeApply typeK typeI) typeErr 
typeS = maybeTryGetValue (typeApply typeU typeK) typeErr 
typeSI = maybeTryGetValue (typeApply typeS typeI) typeErr 
typeM = maybeTryGetValue (typeApply typeSI typeI) typeErr
typeKS = maybeTryGetValue (typeApply typeK typeS) typeErr
typeSKS = maybeTryGetValue (typeApply typeS typeKS) typeErr
typeB = maybeTryGetValue (typeApply typeSKS typeK) typeErr
typeSB = maybeTryGetValue (typeApply typeS typeB) typeErr
typeT = maybeTryGetValue (typeApply typeSB typeI) typeErr
typeTM = maybeTryGetValue (typeApply typeT typeM) typeErr

typeI1 = maybeTryGetValue (typeApply typeM typeI) typeErr
typeI2 = maybeTryGetValue (typeApply typeTM typeI) typeErr
typeI3 = maybeTryGetValue (typeApply typeB typeI) typeErr
typeI4 = maybeTryGetValue (typeApply typeM typeU) typeErr
typeI5 = maybeTryGetValue (typeApply typeM typeKI) typeErr

typeCB = TypeAbstraction (TypeAbstraction typeUa typeUb)
                         (TypeAbstraction (TypeAbstraction typeUb typeUc) (TypeAbstraction typeUa typeUc))
typeCBM = maybeTryGetValue (typeApply typeCB typeM) typeErr
typeBM = maybeTryGetValue (typeApply typeB typeM) typeErr
typeY = maybeTryGetValue (typeApply typeBM typeCBM) typeErr

typeMM = maybeTryGetValue (typeApply typeM typeM) typeErr


'' CONSTANTS
_eCharBrOpen = strHead "("
_eCharBrClose = strHead ")"
_eCharSqBrOpen = strHead "["
_eCharSqBrClose = strHead "]"
_eCharComma = strHead ","
_eCharAbstr = strHead "\"
_eCharOr = strHead "|"
_eCharAnd = strHead "&"
_eCharDollar = strHead "$"
_eCharAssign = 61
_eCharComment = 39
_eStrColon = strReturn 58
_eIsQuot = \x or (isEQ x 34) (isEQ x 96)
_eIsNewLine = \x or (isEQ x 10) (isEQ x 13)


'' TOKENIZER
' special chars

Schar = ScharParenOpen
      | ScharParenClose
      | ScharAbstraction
      | ScharAssign
      | ScharSqBracketOpen
      | ScharSqBracketClose
      | ScharComma
      | ScharSingleOr
      | ScharDollar

scharID = \s s 0 1 2 3 4 5 6 7 8
scharEQ = \a \b isEQ (scharID a) (scharID b)

schar_String = \x x
        "<PAR_OPEN>"
        "<PAR_CLOSE>"
        "<ABSTRACT>"
        "<ASSIGN>"
        "<SQBR_OPEN>"
        "<SQBR_CLOSE>"
        "<COMMA>"
        "<SINGLE_OR>"
        "<DOLLAR>"

' tokens
Token = TokenSpecialChar schar      ' schar
      | TokenLiteralLower literal   ' S
      | TokenLiteralUpper literal   ' S
      | TokenConstS value           ' S
      | TokenConstN value           ' N
      | TokenComment value          ' S

tokenLiteral = \literal if(isLowerCaseLetter (strHead literal)) (TokenLiteralLower literal) (TokenLiteralUpper literal) 

token_String = \x x
        schar_String
        (\literal strConss ["<LITERALL(", literal, ")>"])
        (\literal strConss ["<LITERALU(", literal, ")>"])
        (\value strConss ["<CONSTS(", value, ")>"])
        (\value strConss ["<CONSTN(", strFromN value, ")>"])
        (k "<COMMENT>")
token_String_list = \xs strJoin (listMap xs token_String) " "

' :: Parser Token
eatParenOpen        = parseBindOperation (parseChar _eCharBrOpen)    $ k $ TokenSpecialChar ScharParenOpen
eatParenClose       = parseBindOperation (parseChar _eCharBrClose)   $ k $ TokenSpecialChar ScharParenClose
eatSqBracketOpen    = parseBindOperation (parseChar _eCharSqBrOpen)  $ k $ TokenSpecialChar ScharSqBracketOpen
eatSqBracketClose   = parseBindOperation (parseChar _eCharSqBrClose) $ k $ TokenSpecialChar ScharSqBracketClose
eatComma            = parseBindOperation (parseChar _eCharComma)     $ k $ TokenSpecialChar ScharComma
eatAbstraction      = parseBindOperation (parseChar _eCharAbstr)     $ k $ TokenSpecialChar ScharAbstraction
eatAssign           = parseBindOperation (parseChar _eCharAssign)    $ k $ TokenSpecialChar ScharAssign
eatSingleOr         = parseBindOperation (parseChar _eCharOr)        $ k $ TokenSpecialChar ScharSingleOr
eatDollar           = parseBindOperation (parseChar _eCharDollar)    $ k $ TokenSpecialChar ScharDollar

eatLiteral = parseBindOperation parseToken (\x tokenLiteral x)
eatConstS  = parseBindOperation (parseBindOverride (parseCharIf _eIsQuot) (parseBindDiscard (parseUntil _eIsQuot) (parseCharIf _eIsQuot))) (\x TokenConstS x)
eatConstN  = parseBindOperation parsenumber (\x TokenConstN x)
eatComment = parseBindOperation (parseBindOverride (parseChar _eCharComment) (parseUntil _eIsNewLine)) (\x TokenComment x)

eatSpecialChar = parseOptions
            [
                eatParenOpen, 
                eatParenClose,
                eatAbstraction,
                eatAssign,
                eatSqBracketOpen, 
                eatSqBracketClose, 
                eatComma,
                eatSingleOr,
                eatDollar
            ]
eatSomething = parseWithWhitespace $ parseOptions 
        [ 
            eatSpecialChar,
            eatLiteral, 
            eatConstS, 
            eatConstN,
            eatComment
        ]
            

' S => M [Token]
token_Process = b parseAcceptFullyConsumed $ parseWhilesuccessful eatSomething

' S => S
token_Run = \s (strFromMaybe i (maybeMap (token_Process s) token_String_list))

' SAMPLE USAGE
' : (strFromMaybe (\f (B strFromN token_Type) f) (parseAcceptFullyConsumed (eatSomething "=")))
' : (token_Run "asd")


'' SYNTAXER

SyntaxExpression = SyntaxName literal                             ' S
                 | SyntaxConstN value                             ' N
                 | SyntaxConstS value                             ' S
                 | SyntaxList list                                ' [SYNTAX]
                 | SyntaxAbstraction literal body                 ' S SYNTAX
                 | SyntaxApplication o1 o2                        ' SYNTAX SYNTAX
                 | SyntaxAssignment literal o                     ' S SYNTAX
                 | SyntaxType literalType listPairInstanceArgs    ' S [(S, [S])]

syntaxCreateApplication = \syntaxes foldl (listTail syntaxes) (listHead syntaxes) SyntaxApplication
syntaxCreateAbstraction = \literals \body foldr literals body (\x \lit SyntaxAbstraction lit x)

syntax_String = y $ \this \x
    x
        (\literal strConss ["literal(", literal, ")"])
        (\value strConss ["constn(", strFromN value, ")"])
        (\value strConss ["consts(", value, ")"])
        (\list strConss ["list(", strJoin (listMap list this) ", ", ")"])
        (\literal \body strConss ["abstract(", literal, ", ", this body, ")"])
        (\o1 \o2 strConss ["apply(", this o1, ", ", this o2, ")"])
        (\literal \o strConss ["assign(", literal, ", ", this o, ")"])
        (\literalType \listPairInstanceArgs strConss ["type(", literalType, "; ", (strJoin (listMap listPairInstanceArgs (\pair strCons (fst pair) (strConss (listMap (snd pair) (strCons " "))))) ", "), ")"])
syntax_String_list = \xs strJoin (listMap xs syntax_String) "; "

' B :=  lit=E | \lit E | lit | constS | constN | (E) | comment | [E*]   'return [Syntax]
' E :=  app  :=  B* | B* $ E                                            'return Syntax


cstrParseAbstractionTail = \e 
    parsePipe
        parseSingle
        (TokenLiteralLower_Dispatch 
            (\literal parseBindOperation 
                e
                (\rese listReturn $ SyntaxAbstraction literal rese)
            ) 
            parseFail)

cstrParseSChar = \specialChar 
    parsePipe
        parseSingle
        (TokenSpecialChar_Dispatch  
            (\schar if(scharEQ specialChar schar)
                (parseReturn i)
                parseFail
            )
            parseFail)

cstrParseLiteralL = parsePipe
        parseSingle
        (TokenLiteralLower_Dispatch parseReturn parseFail)
cstrParseLiteralU = parsePipe
        parseSingle
        (TokenLiteralUpper_Dispatch parseReturn parseFail)
        
cstrParseCloseParen = cstrParseSChar ScharParenClose
cstrParseCloseSqBr = cstrParseSChar ScharSqBracketClose
cstrParseComma = cstrParseSChar ScharComma
cstrParseAssign = cstrParseSChar ScharAssign
cstrParseSingleOr = cstrParseSChar ScharSingleOr
cstrParseDollar = cstrParseSChar ScharDollar

        
cstrParseListTail = \e parseBindDiscard 
                    (parseBindOperation 
                        (
                            parseOption
                            (
                                parseBind
                                    ListCons
                                    e
                                    (parseWhilesuccessful $ parseBindOverride cstrParseComma e)
                            )
                            (parseReturn ListEmpty)
                        )
                        (\list listReturn $ SyntaxList list)
                    )
                    cstrParseCloseSqBr

cstrParseAssignTail = \literal \e parseBindOperation 
                        (parseBindOverride cstrParseAssign e)
                        (\body listReturn $ SyntaxAssignment literal body)

cstrParseDataDefOption = parseBind
                            (\name \args Pair name args)
                            cstrParseLiteralU
                            (parseWhilesuccessful cstrParseLiteralL)
cstrParseDataDefTail2 = parseBind
                            ListCons
                            cstrParseDataDefOption
                            (parseWhilesuccessful (parseBindOverride cstrParseSingleOr cstrParseDataDefOption))
cstrParseDataDefTail = \literal \e parseBindOperation 
                        (parseBindOverride cstrParseAssign cstrParseDataDefTail2) 
                        (\list listReturn $ SyntaxType literal list)

' B:
' Parser [Syntax]
cstrSyntaxSingle = \e
    parsePipe
        parseSingle
        (\token token
            (\schar schar
                (parseBindDiscard (parseBindOperation e listReturn) cstrParseCloseParen)
                parseFail
                (cstrParseAbstractionTail e)
                parseFail
                (cstrParseListTail e)
                parseFail
                parseFail
                parseFail
                parseFail
            )
            (\literal 
                parseOption
                    (cstrParseAssignTail literal e)
                    (parseReturn (listReturn (SyntaxName literal)))
            )
            (\literal 
                parseOption
                    (cstrParseDataDefTail literal e)
                    (parseReturn (listReturn (SyntaxName literal)))
            )
            (\value parseReturn $ listReturn $ SyntaxConstS value)
            (\value parseReturn $ listReturn $ SyntaxConstN value)
            (k parseReturn ListEmpty)
        )

' E:
cstrSyntaxApplication = \e 
                        parsePipe
                            (parseWhilesuccessful $ cstrSyntaxSingle e)
                            (\list 
                                (\ops 
                                    if(listIsEmpty ops) 
                                    parseFail
                                    (parseBindOperation
                                        (parseOption
                                            (parseBindOperation (parseBindOverride cstrParseDollar e) listReturn)
                                            (parseReturn ListEmpty)
                                        )
                                        (\tail
                                            (\ops foldl
                                                (listTail ops) 
                                                (listHead ops) 
                                                (\x \y SyntaxApplication x y))
                                            (listConcat ops tail))
                                    )
                                ) (listBind list i)
                            )

cstrSyntaxEverything = parseWhilesuccessful $ y cstrSyntaxApplication

' [TOKEN] => M [SyNTAX]
syntax_Process = b parseAcceptFullyConsumed cstrSyntaxEverything

' S => S
syntax_Run = \s strFromMaybe i $ maybeMap (maybeBind (token_Process s) syntax_Process) syntax_String_list


NativeDefinition = NativeAssignment literal o   ' S Native
NativeExpression = NativeLiteral literal        ' S
                 | NativeConstN value           ' N
                 | NativeConstS value           ' S
                 | NativeApplication o1 o2      ' Native Native
        
getCollisionFreeLiteral = \literal strCons ":arg:" literal


nativeExpr_String = y(\this \x
    x
        (\literal strConss ["literal(", literal, ")"])
        (\value strConss ["constn(", strFromN value, ")"])
        (\value strConss ["consts(", value, ")"])
        (\o1 \o2 strConss ["apply(", this o1, ", ", this o2, ")"])
    )
nativeDef_String = y $ \this \x x $ \literal \o strConss ["assign(", literal, ", ", nativeExpr_String o, ")"]
    
nativeDef_String_list = \xs strJoin (listMap xs nativeExpr_String) "; "
nativeExpr_String_list = \xs strJoin (listMap xs nativeDef_String) "; "

nativeI = NativeLiteral ":bound:i"
nativeK = NativeLiteral ":bound:k"
nativeB = NativeLiteral ":bound:b"
nativeC = NativeLiteral ":bound:c"
nativeS = NativeLiteral ":bound:s"
nativeY = NativeLiteral ":bound:y"
nativeListEmpty = NativeLiteral "ListEmpty"
nativeListCons = NativeLiteral "ListCons"
nativeStrToN = NativeLiteral "strToN"
native0 = NativeLiteral "Zero"
native1 = NativeLiteral "one"
native2 = NativeLiteral "two"
native3 = NativeLiteral "three"
nativeSucc = NativeLiteral "Succ"
nativeMul = NativeLiteral "mul"
nativeQadd = NativeLiteral "_qadd"

isNativeLiteral = \lit \nat NativeLiteral_Dispatch 
        (\literal strEquals lit literal)
        False
        nat

' NativeExpression => S => B
nativeContainsLit = y(\this \n \lit
    n
        (\literal strEquals lit literal)
        (\value False)
        (\value False)
        (\o1 \o2 or (this o1 lit) (this o2 lit))
    )

' S => S
finalizeLiteral = \s
    if(strStartsWith s ":bound:")
        (strSkip s 7)
        s

' NATIVE => NATIVE
finalizeNativeExpr =
    y(\this \n
        n
            (\literal NativeLiteral (finalizeLiteral literal))
            (\value n)
            (\value n)
            (\o1 \o2 (\a1 \a2
                (\defres 
                    if(isNativeLiteral "y" a1)
                    (
                        NativeApplication_Dispatch
                        (\i1 \i2 if(isNativeLiteral "k" i1) i2 defres)
                        defres
                        a2
                    )
                    defres
                )
                (NativeApplication a1 a2)
            ) (this o1) (this o2))
    )
finalizeNativeDefs = \n n (\literal \o NativeAssignment literal (finalizeNativeExpr o))

_03ToNative = \n n native0 (\n n native1 (\n n native2 (\n n native3 (k native0))))
_nToNative = \n (\d \m
    if (isZero d) 
        m 
        (NativeApplication 
            (NativeApplication 
                nativeQadd 
                m
            ) 
            (_nToNative d)
        )) (div n 4) (_03ToNative $ mod n 4)
_sToNative = \value foldr value nativeListEmpty (\value \item NativeApplication (NativeApplication nativeListCons (_nToNative item)) value)

' SYNTAX => NATIVE
_syntaxToNative = y $ \this \syntax
    syntax
        (\literal NativeLiteral literal)
        _nToNative
        _sToNative
        (\list foldr list nativeListEmpty (\list \item NativeApplication (NativeApplication nativeListCons (this item)) list))
        (\literal \body 
            (y(\strip \lit \nbody
                NativeApplication_Dispatch
                (\a \b
                    if (nativeContainsLit a lit)
                    (
                        if (nativeContainsLit b lit)
                        (NativeApplication (NativeApplication nativeS (strip lit a)) (strip lit b))
                        (NativeApplication (NativeApplication nativeC (strip lit a)) b)
                    )
                    (
                        if (nativeContainsLit b lit)
                        ( ' check for: \b a b
                            if(NativeLiteral_Dispatch (k True) False b)
                            a
                            (NativeApplication (NativeApplication nativeB a) (strip lit b))
                        )
                        (NativeApplication nativeK nbody)
                    )
                )
                (
                    if (nativeContainsLit nbody lit)
                    nativeI
                    (NativeApplication nativeK nbody)
                )
                nbody
            )) 
            literal 
            (this body)
        )
        (\o1 \o2 NativeApplication (this o1) (this o2))
        (\literal \o NativeAssignment "fail" (NativeConstS "fail"))
        (\typeLiteral NativeAssignment "fail" (NativeConstS "fail")) 
    
_createUniqueNameFromN = \n strCons ":bound:" (strFromN n)
_createUniqueNameFromS = \s strCons ":bound:" s

_syntaxEmitTypeInstance = \items \ctrArgList \index \args \name
    [
        NativeAssignment 
            name
            (
                _syntaxToNative
                (syntaxCreateAbstraction (listConcat args ctrArgList) (syntaxCreateApplication (listMap (listAddFront args (_createUniqueNameFromN index)) SyntaxName)))
            ),
        NativeAssignment
            (strCons name "_Dispatch")
            (
                _syntaxToNative
                (
                    (\argDisp \argAlt \argItem syntaxCreateAbstraction [argDisp, argAlt, argItem] 
                        (syntaxCreateApplication 
                            (ListCons 
                                (SyntaxName argItem)
                                (listMap items (\item 
                                    if(isEQ index (snd item)) 
                                        (SyntaxName argDisp)
                                        (syntaxCreateAbstraction (snd (fst item)) (SyntaxName argAlt))
                                ))
                            )
                        )
                    )
                    (_createUniqueNameFromS "disp")
                    (_createUniqueNameFromS "alt")
                    (_createUniqueNameFromS "item")
                )
            )
    ]
_syntaxEmitTypeStuff = \typeName \items \ctrArgList ' listConcat
    (
        listBind items
        (\item 
            (\pair \index _syntaxEmitTypeInstance items ctrArgList index (snd pair) (fst pair))
            (fst item)
            (snd item)
        )
    )
'    [
'        NativeAssignment
'            (strCons typeName "_ID")
'            (
'                _syntaxToNative
'                (
'                    (\argItem SyntaxAbstraction argItem
'                        (syntaxCreateApplication 
'                            (ListCons 
'                                (SyntaxName argItem)
'                                (listMap items (\item 
'                                    syntaxCreateAbstraction (snd (fst item)) (SyntaxConstN (snd item))
'                                ))
'                            )
'                        )
'                    )
'                    (_createUniqueNameFromS "item")
'                )
'            )
'    ]

_make__ValueDef = \syntaxExpression SyntaxAssignment "__value" syntaxExpression

' SYNTAX => [NATIVE defs]
_syntaxToNativeDefs = \syntax
    syntax
        (\literal       _syntaxToNativeDefs $ _make__ValueDef syntax)
        (\value         _syntaxToNativeDefs $ _make__ValueDef syntax)
        (\value         _syntaxToNativeDefs $ _make__ValueDef syntax)
        (\list          _syntaxToNativeDefs $ _make__ValueDef syntax)
        (\literal \body _syntaxToNativeDefs $ _make__ValueDef syntax)
        (\o1 \o2        _syntaxToNativeDefs $ _make__ValueDef syntax)
        '(\literal \o listReturn (NativeAssignment literal (_syntaxToNative o)))   
        (\literal \o listReturn (NativeAssignment literal 
            (NativeApplication nativeY 
                (_syntaxToNative (SyntaxAbstraction literal o))
            )))   
        (\typeLiteral \pairs 
            (\optionCount \items
                (\ctrArgList _syntaxEmitTypeStuff typeLiteral items ctrArgList)
                (listMap (listTake nats0 optionCount) _createUniqueNameFromN)
            )
            (listCount pairs)
            (listZip pairs nats0 Pair)
        )
syntaxToNative = \s listMap (_syntaxToNativeDefs s) finalizeNativeDefs

' NATIVE => NATIVE
_nlB = NativeLiteral "b"
_nlMB = NativeLiteral "maybeBind"
_nlTA = NativeLiteral "typeApply"
nativeToTypeNative = \native native
            (\literal NativeLiteral (strCons literal "_Type"))
            (\value NativeLiteral "Zero_Type")
            (\value NativeLiteral "ListEmpty_Type")
            (\o1 \o2 
                NativeApplication
                    (NativeApplication _nlMB (nativeToTypeNative o1))
                    (NativeApplication 
                        (NativeApplication 
                            _nlB
                            (NativeApplication _nlMB (nativeToTypeNative o2))) 
                        _nlTA)
            )
nativeDefToTypeNative = \native native
            (\literal \o NativeAssignment
                (strCons literal "_Type")
                (nativeToTypeNative o)
            )

NativeDefinition = NativeAssignment literal o   ' S Native
NativeExpression = NativeLiteral literal        ' S
                 | NativeConstN value           ' N
                 | NativeConstS value           ' S
                 | NativeApplication o1 o2      ' Native Native            

' NATIVE => S
nativeExprToExe = \n n
            (\literal literal)
            (\value strFromN value)
            (\value (straddBack (straddFront value 34) 34))
            (\o1 \o2 (strConss [nativeExprToExe o1, " ", nativeExprToExe o2, "."]))
nativeDefToExe = \n strCons (n (\literal \o (strConss [literal, " ", nativeExprToExe o]))) "."

' ENV => NATIVE => (???, ENV)
nativeToObj = y $ \this \env \n n
        (\literal Pair (maybeGetValue (env literal)) env) 'handle errors
        (\value   Pair value env)
        (\value   Pair value env)
        (\o1 \o2  Pair ((fst (this env o1)) (fst (this env o2))) env)


' S => S
native_Run = \s strFromMaybe i $ maybeMap 
                                    (maybeMap (maybeBind (token_Process s) syntax_Process) (\l listBind l syntaxToNative))
                                    (\ns strJoin (listMap ns nativeDefToExe) "; ")
                                    ' native_String_list

' [SYNTAX] => M [NATIVE]
native_Process = \synts maybeReturn $ listBind synts syntaxToNative

' [NATIVE] => S
output_Process = \natives strConss $ listMap natives nativeDefToExe

' [NATIVE] => S
output_ProcessType = \natives strConss $ listMap natives $ b nativeDefToExe nativeDefToTypeNative
' S => S
pipeType = \s
    maybeTryGetValue (
    maybeMap (
    maybeBind (
    maybeBind 
        (token_Process s)
        syntax_Process)
        native_Process)
        output_ProcessType)
    ""


' S => S
pipe = \s
    maybeTryGetValue (
    maybeMap (
    maybeBind (
    maybeBind 
        (token_Process s)
        syntax_Process)
        native_Process)
        output_Process)
    ""

' S => S
fullDebug = \s strConss
    [
        newLine, newLine,
        token_Run s,
        newLine, newLine,
        syntax_Run s,
        newLine, newLine,
        native_Run s,
        newLine, newLine
    ]


' ENV => S => M X
run2 = \menv \str maybeMap 
                    (maybeBind (token_Process str) syntax_Process) 
                    (\synt fst 
                            (nativeToObj
                                menv
                                (_syntaxToNative $ listHead synt)
                    ))
